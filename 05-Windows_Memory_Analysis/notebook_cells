- id: 1426863844370
  source:
  - '# Windows memory analysis'
  - ''
  - In this chapter we look into some of the information we may retrieve from windows
    memory analysis.  We first consider the Windows executable file format - the Portable
    Executable (PE) file format. How does the kernel map PE files into memory? Can
    we recover PE files from memory?
  - ''
  - We then examine how the kernel manages the windows Registry - a source of highly
    valuable forensic artifacts.
  type: markdown
- id: 1426887406318
  source:
  - '## How does a PE file get mapped into memory?'
  - ''
  - 'The Portable Executable (PE) file format was specifically designed to make it
    efficient to map into memory. The basic design goal was to divide the file into
    sections, and allow the kernel to create file mappings between sections on disk
    to memory. We have previously seen how a file mapping (in windows terminology
    - a *Section Object*) can make the file appear to be loaded completely into the
    virtual address space. '
  - ''
  - Initially when the file mapping is created, the page tables are setup in such
    a way that the PTEs are marked invalid - I.e. none of the mapped pages are actually
    resident in memory, and the Valid bit of the PTE is 0. If the CPU attempts to
    access a page controlled by such a PTE, the hardware will generate a page fault
    and call the kernel's "page fault handler". The page fault handler recognizes
    this PTE as referring to a mapped file, and therefore will read the file into
    a new page, update the PTE to point at the new page and reissue the page fault.
  - ''
  - The overall effect of this process is that when parts of the file are mapped into
    memory, only a few pages (those that were accessed) are actually copied into memory.
  type: markdown
- id: 1426888533025
  source:
    caption: A Diagram of a PE executable.
    files:
    - name: English (64 bits) - Imgur.jpg
      type: image/jpeg
    size: 0
  type: fileupload
- id: 1426889813479
  source:
  - We have earlier seen how the VAD show us how memory areas are used by the process.
    For this example, we will inspect an innocent process in our image called "LiteAgent.exe".
  type: markdown
- id: 1426889872176
  source:
    arguments:
      proc_regex: LiteAgent.exe
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      - default: null
        help: A regular expression to filter VAD filenames.
        name: regex
        positional: false
        short_opt: ''
      - default: null
        help: Only print the vad corresponding to this offset.
        name: offset
        positional: false
        short_opt: ''
        type: IntParser
      description: "Concise dump of the VAD.\n\n    Similar to windbg's !vad.\n  \
        \  "
      name: vad
      requirements:
      - profile
      - physical_address_space
      short_description: Concise dump of the VAD.
    session_id: 1
  type: rekallplugin
- id: 1426889918145
  source:
  - We  can see the process has the executable loaded from **\Program Files\Amazon\XenTools\LiteAgent.exe**.  We
    see that this file is mapped into the process address space between *0x07ff6ae100000*
    and *0x07ff6ae12cfff*.  The VAD entry simply says that this entire virtual address
    region is mapped from the file, but we do not actually know which of these pages
    are valid and in memory. We know that a mapped file is simply a placeholder, and
    that some of the pages may be invalid. If the CPU tried to access them, then the
    kernel will read those back from the file, but which pages are in memory?
  - ''
  - We can answer this question using the *vadmap* plugin. This plugin walks over
    virtual memory ranges in the VAD and displays the state of each page. We need
    to be careful to specify start and end addresses to ensure the output is not too
    much. In this case we only care about the range covering the executable itself.
  type: markdown
- id: 1426890277871
  source:
    arguments:
      end: 140697459150847
      proc_regex: LiteAgent.exe
      start: 140697458966528
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      - default: 1
        help: 'An integer reflecting the amount of desired output: 0 = quiet, 10 =
          noisy. Default: 1'
        name: verbosity
        positional: false
        short_opt: V
        type: IntParser
      - default: 0
        help: Start reading from this page.
        name: start
        positional: false
        short_opt: ''
        type: IntParser
      - default: 9223372036854776000
        help: Stop reading at this offset.
        name: end
        positional: false
        short_opt: ''
        type: IntParser
      description: Show physical addresses for all VAD pages.
      name: vadmap
      requirements:
      - profile
      - physical_address_space
      short_description: Show physical addresses for all VAD pages.
    session_id: 1
  type: rekallplugin
- id: 1426890372103
  source:
  - We can see that the first 0x13 pages are valid - i.e. those memory pages will
    contain valid data and we can read them. The next page however, is a file mapping
    to **\Program Files\Amazon\XenTools\LiteAgent.exe**. This means that the page
    is not resident in memory. Instead the Page Table Entry for this page points at
    a *Section Object* describing the exact file we can read from.
  - ''
  - Let us see how Rekall performs the translation between Virtual Address to Physical
    Address. First we must remember to switch Rekall into the process context of the
    process LiteAgent.exe.
  type: markdown
- id: 1426890553433
  source:
    arguments:
      proc_regex: LiteAgent.exe
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      description: Set the current process context.
      name: cc
      requirements:
      - profile
      - physical_address_space
      short_description: Set the current process context.
    session_id: 1
  type: rekallplugin
- id: 1426890569336
  source:
    arguments:
      virtual_address: '0x7ff6ae100000'
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      - help: The Virtual Address to examine.
        name: virtual_address
        positional: true
        required: true
        short_opt: ''
        type: SymbolAddress
      description: Prints information about the virtual to physical translation.
      name: vtop
      requirements:
      - profile
      - physical_address_space
      short_description: Prints information about the virtual to physical translation.
    session_id: 1
  type: rekallplugin
- id: 1426890621962
  source:
  - Rekall translates the address through the process page tables and recognizes that
    the PTE is *Valid*, meaning that the page is resident in memory. If we dump the
    page using the *dump* plugin we should be able to easily recognize the familiar
    MZ header, and the message "This program cannot be run in DOS mode". This is indeed
    the executable header which is resident.
  type: markdown
- id: 1426890710611
  source:
    arguments:
      offset: '0x7ff6ae100000'
    plugin:
      arguments:
      - help: An offset to hexdump.
        name: offset
        positional: true
        short_opt: ''
        type: SymbolAddress
      - default: null
        help: The address space to use.
        name: address_space
        positional: false
        short_opt: a
      - default: null
        help: Dump this string instead.
        name: data
        positional: false
        short_opt: ''
      - default: null
        help: Maximum length to dump.
        name: length
        positional: false
        short_opt: ''
        type: IntParser
      - default: false
        help: Should headers be suppressed?.
        name: suppress_headers
        positional: false
        short_opt: ''
        type: Boolean
      description: Hexdump an object or memory location.
      name: dump
      requirements: []
      short_description: Hexdump an object or memory location.
    session_id: 1
  type: rekallplugin
- id: 1426890794946
  source:
  - Lets understand the virtual mapping for the address 0x7ff6ae113000, which the
    vadmap plugin indicated is the first page not resident.
  type: markdown
- id: 1426890844870
  source:
    arguments:
      virtual_address: '0x7ff6ae113000'
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      - help: The Virtual Address to examine.
        name: virtual_address
        positional: true
        required: true
        short_opt: ''
        type: SymbolAddress
      description: Prints information about the virtual to physical translation.
      name: vtop
      requirements:
      - profile
      - physical_address_space
      short_description: Prints information about the virtual to physical translation.
    session_id: 1
  type: rekallplugin
- id: 1426890905524
  source:
  - Rekall analyzes the PTE and finds that the Valid bit is unset. When the hardware
    does this translation it will generate a page fault. The pagefault handler is
    free to use the rest of the bits in the PTE to signify anything. In this case
    we find that the PTE is a special type called a "VAD Prototype PTE". This means
    Rekall must consult the VAD for this address to see where the real PTE might be.
    The real PTE is pointing at a section object.
  - ''
  - You can inspect the content of each struct by clicking the highlighted address
    and selecting "Struct" view. This will show the struct in a modal window which
    you can inspect further. In this case *Subsection.ControlArea.FileObject.Filename*.
  - ''
  - '## Dumping PE files from memory.'
  - ''
  - The reason we spent so much time understanding the nature of file mapping is that
    we ultimately want to understand if it is possible to dump the file from memory.
    Unfortunately we have seen that this process is imperfect. Not all pages in the
    executable file are mapped into memory. It is also important to note that pages
    that are not mapped into memory are **not** resident in the page file. This makes
    sense - the OS does not need to copy the data back to the page file. If the file
    content is needed again it will be read from the file on disk - why waste valuable
    pagefile space for data already found on disk?
  - ''
  - 'For the forensic analyst we simply can not read non-resident pages from the memory
    image. We would have to go back to the filesystem to retrieve this data.  Therefore
    dumping files from memory in general is not a good technique, and should probably
    only be considered as a necessary hack. The only reason you would want to do this
    is if you forget to acquire the files during acquisition - it is simply not forensically
    sound. In future we will build a way to perform some live analysis at acquisition
    time to determine all the files we should be acquiring from the filesystem. '
  - ''
  - There are two plugins which do much the same thing - The *pedump* plugin is designed
    to dump PE binaries, while the *dumpfiles* plugin can dump any kind of mapped
    file. The *pedump* plugin requires the base address of the PE file (i.e. the MZ
    header address), while the *dumpfiles* plugin does not - it just dumps all files
    mapped into the process address space.
  type: markdown
- id: 1426893420865
  source:
    arguments:
      proc_regex: LiteAgent.exe
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      - default: null
        help: 'Path suitable for dumping files. (Default: Use current directory)'
        name: dump_dir
        positional: false
        required: false
        short_opt: D
      - default: []
        help: Kernel addresses of _FILE_OBJECT structs.
        name: file_objects
        positional: false
        short_opt: ''
        type: ArrayIntParser
      description: "Dump files from memory.\n\n    The interface is loosely based\
        \ on the Volatility plugin of the same name,\n    although the implementation\
        \ is quite different.\n    "
      name: dumpfiles
      requirements:
      - profile
      - physical_address_space
      short_description: Dump files from memory.
    session_id: 1
  type: rekallplugin
- id: 1426894428936
  source:
  - The *pedump* plugin is used by many other plugins which build on. For example
    *procdump* dumps processes (i.e. the main .exe in the process address space),
    *moddump* dumps kernel modules etc.
  type: markdown
- id: 1426893714082
  source:
    arguments:
      proc_regex: LiteAgent.exe
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      - default: null
        help: 'Path suitable for dumping files. (Default: Use current directory)'
        name: dump_dir
        positional: false
        required: false
        short_opt: D
      - dest: SUPPRESS
        help: A file like object to write the output.
        name: out_fd
        positional: false
        short_opt: ''
      description: Dump a process to an executable file sample
      name: procdump
      requirements:
      - profile
      - physical_address_space
      short_description: Dump a process to an executable file sample
    session_id: 1
  type: rekallplugin
- id: 1426889414636
  source:
  - '## The Windows Registry'
  - ''
  - Windows uses a centralized repository for key/value pairs called the **Windows
    Registry**.  Most applications use the registry to store internal configuration
    information, and the operating system itself stores crucial data in the registry.
  - ''
  - Since the registry is used so heavily, the kernel contains a specialized mechanism
    to cache it in memory. The registry is broken into hives. Typically hives are
    stored in their own files on disk, but some hives are volatile - i.e. they only
    exist in memory. Each hive is split up into cells called **HBIN**. The HBINs are
    referenced through a 3 level table structure (similar to page tables), which allow
    HBINs to reside on disk.
  type: markdown
- id: 1426864893393
  source:
    caption: Registry in Memory
    files:
    - name: registry.jpg
      type: image/jpeg
    size: 0
  type: fileupload
- id: 1426865013592
  source:
  - Rekall can display all the hives the system knows about using the *hives* plugin.
  type: markdown
- id: 1426867672489
  source:
    arguments: {}
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - default: null
        help: A list of hive offsets as found by hivelist. If not provided we call
          hivelist ourselves and list the keys on all hives.
        name: hive-offsets
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to filter hive names.If not provided we use all hives.
        name: hive_regex
        positional: false
        short_opt: ''
      description: List all the registry hives on the system.
      name: hives
      requirements:
      - profile
      - physical_address_space
      short_description: List all the registry hives on the system.
    session_id: 1
  type: rekallplugin
- id: 1426867987935
  source:
  - Rekall has a complete registry parser built in. This means we can read arbitrary
    keys directly from memory. This is providing of course the relevant HBIN data
    is still resident in memory.
  - ''
  - For example, we can list all the windows services directly from the registry key
    "ControlSet001/services/".
  type: markdown
- id: 1426884633367
  source:
    arguments:
      key: ControlSet001/services/
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - default: null
        help: A list of hive offsets as found by hivelist. If not provided we call
          hivelist ourselves and list the keys on all hives.
        name: hive-offsets
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to filter hive names.If not provided we use all hives.
        name: hive_regex
        positional: false
        short_opt: ''
      - default: ''
        help: Registry key to print.
        name: key
        positional: false
        short_opt: k
      - default: false
        help: If set print the entire subtree.
        name: recursive
        positional: false
        short_opt: r
        type: Boolean
      description: Print a registry key, and its subkeys and values
      name: printkey
      requirements:
      - profile
      - physical_address_space
      short_description: Print a registry key, and its subkeys and values
    session_id: 1
  type: rekallplugin
- id: 1426884687540
  source:
  - We can also enumerate all system users by reading the SAM as cached in memory.
  type: markdown
- id: 1426884837093
  source:
    arguments: {}
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - default: null
        help: A list of hive offsets as found by hivelist. If not provided we call
          hivelist ourselves and list the keys on all hives.
        name: hive-offsets
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to filter hive names.If not provided we use all hives.
        name: hive_regex
        positional: false
        short_opt: ''
      description: "Enumerate all users of this system.\n\n    Ref:\n    samparse.pl\
        \ from RegRipper.\n\n    # copyright 2012 Quantum Analytics Research, LLC\n\
        \    # Author: H. Carvey, keydet89@yahoo.com\n    "
      name: users
      requirements:
      - profile
      - physical_address_space
      short_description: Enumerate all users of this system.
    session_id: 1
  type: rekallplugin
- id: 1426884874012
  source:
  - It is possible to dump the registry hives from memory. Of course this will only
    be able to dump those hives which are paged in from the disk. Some external registry
    handling tools are unable to handle partial registry files, such as the ones we
    get when dumping out of memory.
  - ''
  - You can download all the dumped files from the GUI by clicking the "Download All
    files" button.
  type: markdown
- id: 1426884958626
  source:
    arguments: {}
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - default: null
        help: A list of hive offsets as found by hivelist. If not provided we call
          hivelist ourselves and list the keys on all hives.
        name: hive-offsets
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to filter hive names.If not provided we use all hives.
        name: hive_regex
        positional: false
        short_opt: ''
      - default: null
        help: 'Path suitable for dumping files. (Default: Use current directory)'
        name: dump_dir
        positional: false
        required: false
        short_opt: D
      description: Dump all registry hives from memory into a dump directory.
      name: regdump
      requirements:
      - profile
      - physical_address_space
      short_description: Dump all registry hives from memory into a dump directory.
    session_id: 1
  type: rekallplugin
- id: 1426885068082
  source:
  - Rekall uses the registry to augment much of the information it displays. For example,
    the *Tokens* plugin shows the SID (Security Identifiers) for  each running process.
    Lets find out who launched the winpmem process. Rekall uses the information in
    the SAM to resolve the username for the SIDs found in the process token.
  type: markdown
- id: 1426885183556
  source:
    arguments:
      proc_regex: winpmem
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      description: Print the SIDs owning each process token.
      name: tokens
      requirements:
      - profile
      - physical_address_space
      short_description: Print the SIDs owning each process token.
    session_id: 1
  type: rekallplugin
- id: 1426885775000
  source:
  - '# Timers.'
  - ''
  - 'We have previously seen many methods to detect long running processes. Since
    malware needs to persist on the system, it generally needs to ensure later execution.
    Many malware have a need to periodically do stuff such as contact a command and
    control channel or ensure the system is still infected (and potentially reinfect
    a cleaned out system). The Windows kernel has the ability to launch tasks at specified
    times or intervals: The _KTIMER facility.'
  - A malicious kernel driver may register a timer callback and get called periodically
    or simply be called at a later time.
  - ''
  - The *timers* plugin enumerates these callbacks and attempts to resolve the callback
    address back to a known module. Unfortunately, some of Microsoft's patch guard
    facility are implemented as timers, so steps have been taken to obfuscate the
    real addresses. This plugin implements the necessary algorithms to de-obfuscate
    these addresses and also resolve the exact time where the timer function will
    fire next.
  - ''
  - 'Note that Rekall resolves an address into a consistent name:'
  - ''
  - '- If the name of the symbol at this address is known exactly, the symbol is shown
    as *module name*!*symbol name*. For example *nt!CmpLazyFlushDpcRoutine*.'
  - '- If the address is close to another symbol we show it as an offset from that
    symbol. Note that the actual purpose of the callback may not be related to the
    name of the symbol Rekall shows in this case. For example: *dxgkrnl!TraceDxgkPerformanceWarning
    + 0x84*'
  - '- If the address is not close to any particular known symbol but lies within
    a known kernel module, Rekall denotes it as an offset from the start of the kernel
    module. For example *netbt + 0x21d0*.'
  - ''
  - 'Note that Rekall resolves symbol names through the following sources in order:'
  - ''
  - 1. If a profile is known for the kernel module in the profile repository, Rekall
    will fetch and use it. In this case exact addresses for all functions are typically
    known.
  - 2. Failing this, Rekall will scan the export table of the kernel module to learn
    about exported symbol names. This information is not as complete as is available
    in the profile but might help.
  - ''
  - The below also shows if the timer is programmed to go off repeatedly and what
    is its firing frequency (in microseconds).
  - "\uFFFC\uFFFC\uFFFC"
  type: markdown
- id: 1426885291268
  source:
    arguments: {}
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      description: "Print kernel timers and associated module DPCs.\n\n    Ref:\n\
        \    http://computer.forensikblog.de/en/2011/10/timers-and-times.html\n  \
        \  "
      name: timers
      requirements:
      - profile
      - physical_address_space
      short_description: Print kernel timers and associated module DPCs.
    session_id: 1
  type: rekallplugin
- id: 1426886882283
  source:
  - '# Kernel modules'
  - ''
  - The windows kernel is extensible by allowing third party kernel modules to be
    loaded into it at runtime. Loading a kernel module is the only supported way to
    get third party code to run inside Ring 0 (kernel mode). On modern versions of
    Windows, kernel modules must be signed to allow them to load.
  - ''
  - When the kernel loads a kernel module, the module's executable (which is stored
    as a PE file on disk) will be mapped into the kernel's virtual address space.
    We have previously seen the same mechanism used for loading a DLL into a process
    - the DLL PE file was mapped into the process address space. The two approaches
    are exactly the same.
  - ''
  - The kernel maintains a list of *\_LDR\_DATA\_TABLE\_ENTRY* structs to keep track
    of loaded kernel modules. The list head is kept at symbol "nt!PsLoadedModuleList"
    and Rekall can therefore list all loaded kernel modules (Since this is a doubly
    linked list it is trivial to unlink once malware has kernel execution so take
    it with a grain of salt).
  - ''
  - The kernel modules are simply mapped PE files as explained before, and therefore
    can be dumped using the **moddump** plugin.
  type: markdown
- id: 1426887264211
  source:
    arguments: {}
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Filter module names by this regex.
        name: name_regex
        positional: false
        short_opt: ''
      - default: null
        help: The address space to use.
        name: address_space
        positional: false
        short_opt: a
      description: Print list of loaded kernel modules.
      name: modules
      requirements:
      - profile
      - physical_address_space
      short_description: Print list of loaded kernel modules.
    session_id: 1
  type: rekallplugin
- id: 1426894489107
  source:
    arguments: {}
    plugin:
      arguments:
      - critical: true
        help: Name of the profile to load. This is the filename of the profile found
          in the profiles directory. Profiles are searched in the profile path order.
        name: profile
        positional: false
        short_opt: p
      - help: The DTB physical address.
        name: dtb
        positional: false
        short_opt: ''
        type: IntParser
      - help: Kernel addresses of eprocess structs.
        name: eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: Physical addresses of eprocess structs.
        name: phys_eprocess
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - help: One or more pids of processes to select.
        name: pid
        positional: false
        short_opt: ''
        type: ArrayIntParser
      - default: null
        help: A regex to select a process by name.
        name: proc_regex
        positional: false
        short_opt: ''
        type: RegEx
      - choices:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        default:
        - PsActiveProcessHead
        - CSRSS
        - PspCidTable
        - Sessions
        - Handles
        help: Method to list processes (Default uses all methods).
        name: method
        positional: false
        short_opt: ''
        type: ChoiceArray
      - default: null
        help: 'Path suitable for dumping files. (Default: Use current directory)'
        name: dump_dir
        positional: false
        required: false
        short_opt: D
      - dest: SUPPRESS
        help: A file like object to write the output.
        name: out_fd
        positional: false
        short_opt: ''
      - default: .+
        help: A Regular expression for selecting the dlls to dump.
        name: regex
        positional: false
        short_opt: ''
      description: Dump kernel drivers from kernel space.
      name: moddump
      requirements:
      - profile
      - physical_address_space
      short_description: Dump kernel drivers from kernel space.
    session_id: 1
  type: rekallplugin
- id: 1426895005156
  source:
  - '# Conclusions'
  - ''
  - 'This chapter focused on extracting files from memory. First we learned how files
    are mapped into memory and in particular how PE files are mapped. We learned that
    not all file pages are resident in memory, and therefore we are not likely to
    have complete files when we extract them from memory. '
  - ''
  - We then saw that the registry files are mapped into memory and we learned how
    these can be read. Again we find that not all parts of the registry file are mapped
    into memory. Although we can dump these out, there are likely to be holes padded
    with zeros for those HBINs which are not mapped.
  type: markdown
