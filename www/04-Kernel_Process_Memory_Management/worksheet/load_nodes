{"cells": [{"source": ["# Kernel Process Management.", "", "The previous chapter covered the mechanisms the kernel uses to manage its own memory. We also touched on how the kernel keeps track of metadata about the process such as the process name and the list headed from *PsActiveProcessHead*. ", "", "In this chapter we expand on how the kernel manages the process, and how the process sees its own internal state as a result.", "", "## Handles.", "", "When the process wants to get access to external resources, the process must request the kernel to provide these. For example, when the process wants to open a file, it must go through a well controlled procedure:", "", "1. First the process makes a system call to open the file.", "2. The kernel checks the process privilege tokens, and NTFS permissions and if the process is entitles to open this file, the kernel creates a *File Object* to keep track of the file. ", "3. The process then uses this File Object to make further operations, like reading, writing etc.", "", "We saw earlier that kernel objects are used by the kernel to keep track of internal objects. However kernel objects must be protected from userspace - i.e. the process must not be allowed to directly read all the information contained in the kernel object, let alone modify it. ", "", "However, the process needs to receive something back that represents the open file, so they can continue operating on it. The kernel must therefore give something back to the process to represent the open file, without actually giving back the file object itself. The solution to this problem is to place the kernel's file object inside kernel memory (i.e. inaccessible to the process), but give the process a reference or address to this memory. ", "", "The process can not use this reference directly because it can not access kernel memory directly, instead, the process simply passes the address back to the kernel on subsequent operations, and the kernel retrieves the real file object.", "", "The reference to the file object is termed a \"Handle\" to a file object or a file handle. The handle is simply a reference to an entry in the handle table (Note in practice the handle table is multi level but this is merely an implementation detail). This is illustrated in the diagram below."], "type": "markdown", "id": 1426768198051}, {"source": {"files": [{"type": "image/jpeg", "name": "handle_table.jpg"}], "caption": "Process Handle Table diagram.", "size": 0}, "type": "fileupload", "id": 1426769888813}, {"source": ["The handle table is kept in kernel space associates with the _EPROCESS object. Each process has its own handle table. The handle table contains pointers to kernel objects representing kernel controlled resources (e.g. a _FILE_OBJECT).  The process can not directly read the file object. When the process wants to open a file it makes a system call requesting the file to be opened. The kernel creates the associated _FILE_OBJECT and places it into the process's object table. The process then receives an index into the process table (e.g. the number 2).", "", "For subsequent operations with this file object, the process simply passes the handle back to the kernel. For example, if the process wants to read from the file, it will pass the handle back to the kernel in a system call. The kernel will then use this index to retrieve the actual kernel object, read some data and provide it back to the process.", "", "Therefore the process's handle table keeps a reference to all the kernel objects that this process is interacting with. There are many types of kernel objects (recall the *object_types* plugin), such as registry keys, files, directories, event objects, mutants etc. By enumerating all the handles a process has open we get an idea of what this process is trying to do. For example, malware might have a log file open to write key strokes or other captured information. By examining its handle table we can spot the open log file and further investigate.", "", "The most important thing that handle tables provide is that they tie back kernel objects to the processes that own these objects. We have previously seen how to find many types of kernel objects, such as open files, registry keys etc - either through pool scanning techniques or through list enumeration techniques. However, handle tables provide the missing link between these kernel structures and processes.", "", "Lets examine some handle tables (It is recommended that you restrict the handle plugin with a pid because it produces a lot of output!)."], "type": "markdown", "id": 1426769937998}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "List processes for windows.", "description": "List processes for windows.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}], "name": "pslist"}}, "type": "rekallplugin", "id": 1427499101549}, {"source": ["Lets examine the handles for one of the internet explorer processes."], "type": "markdown", "id": 1426770776355}, {"source": {"arguments": {"pid": [2044]}, "session_id": 1, "plugin": {"short_description": "Print list of open handles for each process", "description": "Print list of open handles for each process", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": false, "type": "ArrayStringParser", "short_opt": "t", "name": "object_types", "help": "Types of objects to show."}], "name": "handles"}}, "type": "rekallplugin", "id": 1426770671083}, {"source": ["## Process Memory Management and the VAD Tree", "", "In the previous section we have seen how a process can request the kernel to manipulate resources on its behalf. One important resource a process needs to manage is its address space. In previous chapters we have seen that since a process exists in its own virtual address space, it is not able to access arbitrary memory that is not mapped into its address space. We also saw that the virtual address space mappings are controlled by the page tables which the hardware uses to translate access to the physical memory. ", "", "Obviously it is not permitted for the process itself to manage its own page tables (because it could then gain access to arbitrary physical memory). Therefore the kernel must manage the process's page tables on the processes behalf. There are a number of use cases for the process to manipulate its page tables:", "", "1. The process may need to allocate more physical memory for its own use. The process then called VirtualAllocEx() to request its address space to be increased to contain additional physical memory.", "2. The process may want to map a file into its address space. Mapping a file is more efficient than reading a file because the kernel can manage which parts of the file are resident in memory through the file cache.", "3. A process may ask to load a DLL into its address space. This effectively maps the DLL executable file into the address space (same as 2 above).", "", "In reality the process's page tables are quite large and contain many entries. Manipulating each page table entry individually would be very time consuming and slow. Therefore the kernel maintains a separate higher level set of *Virtual Memory Descriptors* which describe high level virtual memory mappings.", "", "The Virtual Memory Descriptors (VAD)  are actually organized in a binary tree (hence VAD Tree) but this is done so that searching through the descriptors is faster. It is merely an optimization and you should not think of the fact that VADs are organized in a tree as meaningful (i.e. the VADs do not necessarily convey a parent-child relationship). It is best to think of VADs as just a set of descriptors for each memory region.", "", "Lets examine the VADs for one of the svchost.exe processes:"], "type": "markdown", "id": 1426772176561}, {"source": {"arguments": {"pid": [724]}, "session_id": 1, "plugin": {"short_description": "Concise dump of the VAD.", "description": "Concise dump of the VAD.\n\n    Similar to windbg's !vad.\n    ", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"default": null, "positional": false, "short_opt": "", "name": "regex", "help": "A regular expression to filter VAD filenames."}, {"positional": false, "short_opt": "", "default": null, "help": "Only print the vad corresponding to this offset.", "type": "IntParser", "name": "offset"}], "name": "vad"}}, "type": "rekallplugin", "id": 1427499085998}, {"source": ["We can see that mapped DLLs are shared with protection EXECUTE_WRITECOPY. This means the pages are executable, and if the binary tries to write to these pages, they will be copies to the process's address space. This is typically used for DLLs which are shared between processes (each process has its own view of the DLL's code but unless the process attempts to change the code, all processes are sharing the same copy of the DLL). ", "", "Note that committed column which indicates how many pages in that range are actually committed to the process (in memory or the pagefile).", "", "## DLL injection.", "", "We have seen that in practice it is difficult to hide a full running process. Although it can be unlinked from some lists it still leaves artifacts in various other lists and pool tags. But in practice there is no need for malware to run in its own process. It is just as good if the malware simply runs inside another process. In that case it may not be so obvious that the malware is running at all.", "", "There are some [standard techniques](http://en.wikipedia.org/wiki/DLL_injection) for injecting a DLL into another process and thereby running code in the context of that process. But how would this look like to the kernel?", "", "Lets take a look at the following Stuxnet memory sample. In particular lets look at the services.exe process:"], "type": "markdown", "id": 1426776312218}, {"source": {"arguments": {"proc_regex": "services"}, "session_id": 2, "plugin": {"short_description": "Concise dump of the VAD.", "description": "Concise dump of the VAD.\n\n    Similar to windbg's !vad.\n    ", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"default": null, "positional": false, "short_opt": "", "name": "regex", "help": "A regular expression to filter VAD filenames."}, {"positional": false, "short_opt": "", "default": null, "help": "Only print the vad corresponding to this offset.", "type": "IntParser", "name": "offset"}], "name": "vad"}}, "type": "rekallplugin", "id": 1427499078655}, {"source": ["The interesting thing to note about this VAD listing is that there are a number of regions mapped with protection \"EXECUTE_READWRITE\". This protection is normally used for memory which will be written to but also executed from. I.e. this data is not coming from an executable file, but it is executed directly from memory.", "", "There are a few legitimate reasons for doing this - for example chrome.exe uses a Just In Time (JIT) compiler to generate code on the fly which will be executed. We can see what is contained in these regions by clicking on the start address and selecting \"HexDump\".", "", "Note that in order to dump or disassemble memory from the context of the services.exe process, we need to put the session into the process context using the \"cc\" plugin."], "type": "markdown", "id": 1426778893290}, {"source": {"arguments": {"pid": [668]}, "session_id": 2, "plugin": {"short_description": "Set the current process context.", "description": "Set the current process context.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}], "name": "cc"}}, "type": "rekallplugin", "id": 1427499072846}, {"source": {"arguments": {"offset": "0x13f0000"}, "session_id": 2, "plugin": {"short_description": "Hexdump an object or memory location.", "description": "Hexdump an object or memory location.", "requirements": [], "arguments": [{"positional": true, "type": "SymbolAddress", "short_opt": "", "name": "offset", "help": "An offset to hexdump."}, {"default": null, "positional": false, "short_opt": "a", "name": "address_space", "help": "The address space to use."}, {"default": null, "positional": false, "short_opt": "", "name": "data", "help": "Dump this string instead."}, {"positional": false, "short_opt": "", "default": null, "help": "Maximum length to dump.", "type": "IntParser", "name": "length"}, {"positional": false, "short_opt": "", "default": false, "help": "Should headers be suppressed?.", "type": "Boolean", "name": "suppress_headers"}], "name": "dump"}}, "type": "rekallplugin", "id": 1426779225633}, {"source": ["This looks like a PE file - judging by the PE header, but it is not coming from an actual file on disk (Judging by the \"Pagefile-backed section\" message this is a regular allocation). This is because this file was copied into this process's address space using [DLL injection](http://www.codeproject.com/Articles/4610/Three-Ways-to-Inject-Your-Code-into-Another-Proces):", "", "1. First a handle to the services.exe process is taken.", "2. Then a memory is allocated in the remote process using the VirtualAllocEx() routine.", "3. The binary image is copied to the remote process using WriteProcessMemory().", "4. Create a remote thread to run the new binary.", "", "This is consistent with what we see. Lets examine the other EXECUTE_READWRITE region by disassembling it:"], "type": "markdown", "id": 1426779286887}, {"source": {"arguments": {"offset": "0x0000000940000"}, "session_id": 2, "plugin": {"short_description": "Disassemble the given offset.", "description": "Disassemble the given offset.", "requirements": [], "arguments": [{"positional": true, "type": "SymbolAddress", "short_opt": "", "name": "offset", "help": "An offset to disassemble. This can also be the name of a symbol with an optional offset. For example: tcpip!TcpCovetNetBufferList."}, {"default": null, "positional": false, "short_opt": "a", "name": "address_space", "help": "The address space to use."}, {"positional": false, "type": "IntParser", "short_opt": "l", "name": "length", "help": "The number of instructions (lines) to disassemble."}, {"positional": false, "short_opt": "e", "default": null, "help": "The end address to disassemble up to.", "type": "IntParser", "name": "end"}, {"positional": false, "short_opt": "", "default": "auto", "help": "Disassemble Mode (AMD64 or I386). Defaults to profile arch.", "choices": ["auto", "I386", "AMD64", "MIPS"], "type": "Choices", "name": "mode"}, {"positional": false, "short_opt": "", "default": false, "help": "If set we do not write table headers.", "type": "Boolean", "name": "suppress_headers"}, {"positional": false, "short_opt": "", "default": false, "help": "If set we follow all branches to cover all code.", "type": "Boolean", "name": "branch"}], "name": "dis"}}, "type": "rekallplugin", "id": 1426779861723}, {"source": ["So we can search for this style of DLL injection by searching for VAD regions mapped executable but that do not have a file backing. This is essentially what the *malfind* plugin does."], "type": "markdown", "id": 1426780023528}, {"source": {"arguments": {}, "session_id": 2, "plugin": {"short_description": "Find hidden and injected code", "description": "Find hidden and injected code", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": false, "short_opt": "D", "default": null, "required": false, "help": "Path suitable for dumping files. (Default: Use current directory)", "name": "dump_dir"}], "name": "malfind"}}, "type": "rekallplugin", "id": 1426780138036}], "sessions": [{"state": {"profile": ["nt/GUID/3844DBB920174967BE7AA4A2C20430FA2", "FileName"], "timezone": ["UTC", "TimeZone"], "ept": [2283466782, "IntParser"], "pagefile": [[], "FileName"], "session_name": ["Win 7 Guest", "String"], "filename": ["../images/Ubuntu14.10_virtualbox.aff4", "FileName"]}, "mro": "InteractiveSession:JsonSerializableSession:Session:object", "id": 160, "session_id": 1}, {"state": {"profile": ["nt/GUID/30B5FB31AE7E4ACAABA750AA241FF3311", "FileName"], "timezone": ["UTC", "TimeZone"], "ept": [null, "IntParser"], "pagefile": [[], "FileName"], "session_name": ["Stuxnet", "String"], "filename": ["../images/stuxnet.vmem.E01", "FileName"]}, "mro": "InteractiveSession:JsonSerializableSession:Session:object", "id": 184, "session_id": 2}], "filename": "/home/scudette/projects/workshop/source/04-Kernel_Process_Memory_Management"}