{"cells": [{"source": ["# Windows memory analysis", "", "In this chapter we look into some of the information we may retrieve from windows memory analysis.  We first consider the Windows executable file format - the Portable Executable (PE) file format. How does the kernel map PE files into memory? Can we recover PE files from memory?", "", "We then examine how the kernel manages the windows Registry - a source of highly valuable forensic artifacts."], "type": "markdown", "id": 1426863844370}, {"source": ["## How does a PE file get mapped into memory?", "", "The Portable Executable (PE) file format was specifically designed to make it efficient to map into memory. The basic design goal was to divide the file into sections, and allow the kernel to create file mappings between sections on disk to memory. We have previously seen how a file mapping (in windows terminology - a *Section Object*) can make the file appear to be loaded completely into the virtual address space. ", "", "Initially when the file mapping is created, the page tables are setup in such a way that the PTEs are marked invalid - I.e. none of the mapped pages are actually resident in memory, and the Valid bit of the PTE is 0. If the CPU attempts to access a page controlled by such a PTE, the hardware will generate a page fault and call the kernel's \"page fault handler\". The page fault handler recognizes this PTE as referring to a mapped file, and therefore will read the file into a new page, update the PTE to point at the new page and reissue the page fault.", "", "The overall effect of this process is that when parts of the file are mapped into memory, only a few pages (those that were accessed) are actually copied into memory."], "type": "markdown", "id": 1426887406318}, {"source": {"files": [{"type": "image/jpeg", "name": "English (64 bits) - Imgur.jpg"}], "caption": "A Diagram of a PE executable.", "size": 0}, "type": "fileupload", "id": 1426888533025}, {"source": ["We have earlier seen how the VAD show us how memory areas are used by the process. For this example, we will inspect an innocent process in our image called \"LiteAgent.exe\"."], "type": "markdown", "id": 1426889813479}, {"source": {"arguments": {"proc_regex": "LiteAgent.exe"}, "session_id": 1, "plugin": {"short_description": "Concise dump of the VAD.", "description": "Concise dump of the VAD.\n\n    Similar to windbg's !vad.\n    ", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"default": null, "positional": false, "short_opt": "", "name": "regex", "help": "A regular expression to filter VAD filenames."}, {"positional": false, "short_opt": "", "default": null, "help": "Only print the vad corresponding to this offset.", "type": "IntParser", "name": "offset"}], "name": "vad"}}, "type": "rekallplugin", "id": 1427499214389}, {"source": ["We  can see the process has the executable loaded from **\\Program Files\\Amazon\\XenTools\\LiteAgent.exe**.  We see that this file is mapped into the process address space between *0x07ff6ae100000* and *0x07ff6ae12cfff*.  The VAD entry simply says that this entire virtual address region is mapped from the file, but we do not actually know which of these pages are valid and in memory. We know that a mapped file is simply a placeholder, and that some of the pages may be invalid. If the CPU tried to access them, then the kernel will read those back from the file, but which pages are in memory?", "", "We can answer this question using the *vadmap* plugin. This plugin walks over virtual memory ranges in the VAD and displays the state of each page. We need to be careful to specify start and end addresses to ensure the output is not too much. In this case we only care about the range covering the executable itself."], "type": "markdown", "id": 1426889918145}, {"source": {"arguments": {"start": 140697458966528, "proc_regex": "LiteAgent.exe", "end": 140697459150847}, "session_id": 1, "plugin": {"short_description": "Show physical addresses for all VAD pages.", "description": "Show physical addresses for all VAD pages.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": false, "short_opt": "V", "default": 1, "help": "An integer reflecting the amount of desired output: 0 = quiet, 10 = noisy. Default: 1", "type": "IntParser", "name": "verbosity"}, {"positional": false, "short_opt": "", "default": 0, "help": "Start reading from this page.", "type": "IntParser", "name": "start"}, {"positional": false, "short_opt": "", "default": 9223372036854776000, "help": "Stop reading at this offset.", "type": "IntParser", "name": "end"}], "name": "vadmap"}}, "type": "rekallplugin", "id": 1427499258126}, {"source": ["We can see that the first 0x13 pages are valid - i.e. those memory pages will contain valid data and we can read them. The next page however, is a file mapping to **\\Program Files\\Amazon\\XenTools\\LiteAgent.exe**. This means that the page is not resident in memory. Instead the Page Table Entry for this page points at a *Section Object* describing the exact file we can read from.", "", "Let us see how Rekall performs the translation between Virtual Address to Physical Address. First we must remember to switch Rekall into the process context of the process LiteAgent.exe."], "type": "markdown", "id": 1426890372103}, {"source": {"arguments": {"proc_regex": "LiteAgent.exe"}, "session_id": 1, "plugin": {"short_description": "Set the current process context.", "description": "Set the current process context.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}], "name": "cc"}}, "type": "rekallplugin", "id": 1427499261439}, {"source": {"arguments": {"virtual_address": "0x7ff6ae100000"}, "session_id": 1, "plugin": {"short_description": "Prints information about the virtual to physical translation.", "description": "Prints information about the virtual to physical translation.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": true, "short_opt": "", "help": "The Virtual Address to examine.", "required": true, "type": "SymbolAddress", "name": "virtual_address"}], "name": "vtop"}}, "type": "rekallplugin", "id": 1426890569336}, {"source": ["Rekall translates the address through the process page tables and recognizes that the PTE is *Valid*, meaning that the page is resident in memory. If we dump the page using the *dump* plugin we should be able to easily recognize the familiar MZ header, and the message \"This program cannot be run in DOS mode\". This is indeed the executable header which is resident."], "type": "markdown", "id": 1426890621962}, {"source": {"arguments": {"offset": "0x7ff6ae100000"}, "session_id": 1, "plugin": {"short_description": "Hexdump an object or memory location.", "description": "Hexdump an object or memory location.", "requirements": [], "arguments": [{"positional": true, "type": "SymbolAddress", "short_opt": "", "name": "offset", "help": "An offset to hexdump."}, {"default": null, "positional": false, "short_opt": "a", "name": "address_space", "help": "The address space to use."}, {"default": null, "positional": false, "short_opt": "", "name": "data", "help": "Dump this string instead."}, {"positional": false, "short_opt": "", "default": null, "help": "Maximum length to dump.", "type": "IntParser", "name": "length"}, {"positional": false, "short_opt": "", "default": false, "help": "Should headers be suppressed?.", "type": "Boolean", "name": "suppress_headers"}], "name": "dump"}}, "type": "rekallplugin", "id": 1426890710611}, {"source": ["Lets understand the virtual mapping for the address 0x7ff6ae113000, which the vadmap plugin indicated is the first page not resident."], "type": "markdown", "id": 1426890794946}, {"source": {"arguments": {"virtual_address": "0x7ff6ae113000"}, "session_id": 1, "plugin": {"short_description": "Prints information about the virtual to physical translation.", "description": "Prints information about the virtual to physical translation.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": true, "short_opt": "", "help": "The Virtual Address to examine.", "required": true, "type": "SymbolAddress", "name": "virtual_address"}], "name": "vtop"}}, "type": "rekallplugin", "id": 1426890844870}, {"source": ["Rekall analyzes the PTE and finds that the Valid bit is unset. When the hardware does this translation it will generate a page fault. The pagefault handler is free to use the rest of the bits in the PTE to signify anything. In this case we find that the PTE is a special type called a \"VAD Prototype PTE\". This means Rekall must consult the VAD for this address to see where the real PTE might be. The real PTE is pointing at a section object.", "", "You can inspect the content of each struct by clicking the highlighted address and selecting \"Struct\" view. This will show the struct in a modal window which you can inspect further. In this case *Subsection.ControlArea.FileObject.Filename*.", "", "## Dumping PE files from memory.", "", "The reason we spent so much time understanding the nature of file mapping is that we ultimately want to understand if it is possible to dump the file from memory. Unfortunately we have seen that this process is imperfect. Not all pages in the executable file are mapped into memory. It is also important to note that pages that are not mapped into memory are **not** resident in the page file. This makes sense - the OS does not need to copy the data back to the page file. If the file content is needed again it will be read from the file on disk - why waste valuable pagefile space for data already found on disk?", "", "For the forensic analyst we simply can not read non-resident pages from the memory image. We would have to go back to the filesystem to retrieve this data.  Therefore dumping files from memory in general is not a good technique, and should probably only be considered as a necessary hack. The only reason you would want to do this is if you forget to acquire the files during acquisition - it is simply not forensically sound. In future we will build a way to perform some live analysis at acquisition time to determine all the files we should be acquiring from the filesystem. ", "", "There are two plugins which do much the same thing - The *pedump* plugin is designed to dump PE binaries, while the *dumpfiles* plugin can dump any kind of mapped file. The *pedump* plugin requires the base address of the PE file (i.e. the MZ header address), while the *dumpfiles* plugin does not - it just dumps all files mapped into the process address space."], "type": "markdown", "id": 1426890905524}, {"source": {"arguments": {"proc_regex": "LiteAgent.exe"}, "session_id": 1, "plugin": {"short_description": "Dump files from memory.", "description": "Dump files from memory.\n\n    The interface is loosely based on the Volatility plugin of the same name,\n    although the implementation is quite different.\n    ", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": false, "short_opt": "D", "default": null, "required": false, "help": "Path suitable for dumping files. (Default: Use current directory)", "name": "dump_dir"}, {"positional": false, "short_opt": "", "default": [], "help": "Kernel addresses of _FILE_OBJECT structs.", "type": "ArrayIntParser", "name": "file_objects"}], "name": "dumpfiles"}}, "type": "rekallplugin", "id": 1427499269108}, {"source": ["The *pedump* plugin is used by many other plugins which build on. For example *procdump* dumps processes (i.e. the main .exe in the process address space), *moddump* dumps kernel modules etc."], "type": "markdown", "id": 1426894428936}, {"source": {"arguments": {"proc_regex": "LiteAgent.exe"}, "session_id": 1, "plugin": {"short_description": "Dump a process to an executable file sample", "description": "Dump a process to an executable file sample", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": false, "short_opt": "D", "default": null, "required": false, "help": "Path suitable for dumping files. (Default: Use current directory)", "name": "dump_dir"}, {"dest": "SUPPRESS", "positional": false, "short_opt": "", "name": "out_fd", "help": "A file like object to write the output."}], "name": "procdump"}}, "type": "rekallplugin", "id": 1427499279630}, {"source": ["## The Windows Registry", "", "Windows uses a centralized repository for key/value pairs called the **Windows Registry**.  Most applications use the registry to store internal configuration information, and the operating system itself stores crucial data in the registry.", "", "Since the registry is used so heavily, the kernel contains a specialized mechanism to cache it in memory. The registry is broken into hives. Typically hives are stored in their own files on disk, but some hives are volatile - i.e. they only exist in memory. Each hive is split up into cells called **HBIN**. The HBINs are referenced through a 3 level table structure (similar to page tables), which allow HBINs to reside on disk."], "type": "markdown", "id": 1426889414636}, {"source": {"files": [{"type": "image/jpeg", "name": "registry.jpg"}], "caption": "Registry in Memory", "size": 0}, "type": "fileupload", "id": 1426864893393}, {"source": ["Rekall can display all the hives the system knows about using the *hives* plugin."], "type": "markdown", "id": 1426865013592}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "List all the registry hives on the system.", "description": "List all the registry hives on the system.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "short_opt": "", "default": null, "help": "A list of hive offsets as found by hivelist. If not provided we call hivelist ourselves and list the keys on all hives.", "type": "ArrayIntParser", "name": "hive-offsets"}, {"default": null, "positional": false, "short_opt": "", "name": "hive_regex", "help": "A regex to filter hive names.If not provided we use all hives."}], "name": "hives"}}, "type": "rekallplugin", "id": 1427499282966}, {"source": ["Rekall has a complete registry parser built in. This means we can read arbitrary keys directly from memory. This is providing of course the relevant HBIN data is still resident in memory.", "", "For example, we can list all the windows services directly from the registry key \"ControlSet001/services/\"."], "type": "markdown", "id": 1426867987935}, {"source": {"arguments": {"key": "ControlSet001/services/"}, "session_id": 1, "plugin": {"short_description": "Print a registry key, and its subkeys and values", "description": "Print a registry key, and its subkeys and values", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "short_opt": "", "default": null, "help": "A list of hive offsets as found by hivelist. If not provided we call hivelist ourselves and list the keys on all hives.", "type": "ArrayIntParser", "name": "hive-offsets"}, {"default": null, "positional": false, "short_opt": "", "name": "hive_regex", "help": "A regex to filter hive names.If not provided we use all hives."}, {"default": "", "positional": false, "short_opt": "k", "name": "key", "help": "Registry key to print."}, {"positional": false, "short_opt": "r", "default": false, "help": "If set print the entire subtree.", "type": "Boolean", "name": "recursive"}], "name": "printkey"}}, "type": "rekallplugin", "id": 1427499285805}, {"source": ["We can also enumerate all system users by reading the SAM as cached in memory."], "type": "markdown", "id": 1426884687540}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "Enumerate all users of this system.", "description": "Enumerate all users of this system.\n\n    Ref:\n    samparse.pl from RegRipper.\n\n    # copyright 2012 Quantum Analytics Research, LLC\n    # Author: H. Carvey, keydet89@yahoo.com\n    ", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "short_opt": "", "default": null, "help": "A list of hive offsets as found by hivelist. If not provided we call hivelist ourselves and list the keys on all hives.", "type": "ArrayIntParser", "name": "hive-offsets"}, {"default": null, "positional": false, "short_opt": "", "name": "hive_regex", "help": "A regex to filter hive names.If not provided we use all hives."}], "name": "users"}}, "type": "rekallplugin", "id": 1427499320869}, {"source": ["It is possible to dump the registry hives from memory. Of course this will only be able to dump those hives which are paged in from the disk. Some external registry handling tools are unable to handle partial registry files, such as the ones we get when dumping out of memory.", "", "You can download all the dumped files from the GUI by clicking the \"Download All files\" button."], "type": "markdown", "id": 1426884874012}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "Dump all registry hives from memory into a dump directory.", "description": "Dump all registry hives from memory into a dump directory.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "short_opt": "", "default": null, "help": "A list of hive offsets as found by hivelist. If not provided we call hivelist ourselves and list the keys on all hives.", "type": "ArrayIntParser", "name": "hive-offsets"}, {"default": null, "positional": false, "short_opt": "", "name": "hive_regex", "help": "A regex to filter hive names.If not provided we use all hives."}, {"positional": false, "short_opt": "D", "default": null, "required": false, "help": "Path suitable for dumping files. (Default: Use current directory)", "name": "dump_dir"}], "name": "regdump"}}, "type": "rekallplugin", "id": 1427499324812}, {"source": ["Rekall uses the registry to augment much of the information it displays. For example, the *Tokens* plugin shows the SID (Security Identifiers) for  each running process. Lets find out who launched the winpmem process. Rekall uses the information in the SAM to resolve the username for the SIDs found in the process token."], "type": "markdown", "id": 1426885068082}, {"source": {"arguments": {"proc_regex": "winpmem"}, "session_id": 1, "plugin": {"short_description": "Print the SIDs owning each process token.", "description": "Print the SIDs owning each process token.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}], "name": "tokens"}}, "type": "rekallplugin", "id": 1427499343156}, {"source": ["# Timers.", "", "We have previously seen many methods to detect long running processes. Since malware needs to persist on the system, it generally needs to ensure later execution. Many malware have a need to periodically do stuff such as contact a command and control channel or ensure the system is still infected (and potentially reinfect a cleaned out system). The Windows kernel has the ability to launch tasks at specified times or intervals: The _KTIMER facility.", "A malicious kernel driver may register a timer callback and get called periodically or simply be called at a later time.", "", "The *timers* plugin enumerates these callbacks and attempts to resolve the callback address back to a known module. Unfortunately, some of Microsoft's patch guard facility are implemented as timers, so steps have been taken to obfuscate the real addresses. This plugin implements the necessary algorithms to de-obfuscate these addresses and also resolve the exact time where the timer function will fire next.", "", "Note that Rekall resolves an address into a consistent name:", "", "- If the name of the symbol at this address is known exactly, the symbol is shown as *module name*!*symbol name*. For example *nt!CmpLazyFlushDpcRoutine*.", "- If the address is close to another symbol we show it as an offset from that symbol. Note that the actual purpose of the callback may not be related to the name of the symbol Rekall shows in this case. For example: *dxgkrnl!TraceDxgkPerformanceWarning + 0x84*", "- If the address is not close to any particular known symbol but lies within a known kernel module, Rekall denotes it as an offset from the start of the kernel module. For example *netbt + 0x21d0*.", "", "Note that Rekall resolves symbol names through the following sources in order:", "", "1. If a profile is known for the kernel module in the profile repository, Rekall will fetch and use it. In this case exact addresses for all functions are typically known.", "2. Failing this, Rekall will scan the export table of the kernel module to learn about exported symbol names. This information is not as complete as is available in the profile but might help.", "", "The below also shows if the timer is programmed to go off repeatedly and what is its firing frequency (in microseconds).", "\ufffc\ufffc\ufffc"], "type": "markdown", "id": 1426885775000}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "Print kernel timers and associated module DPCs.", "description": "Print kernel timers and associated module DPCs.\n\n    Ref:\n    http://computer.forensikblog.de/en/2011/10/timers-and-times.html\n    ", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}], "name": "timers"}}, "type": "rekallplugin", "id": 1427499348037}, {"source": ["# Kernel modules", "", "The windows kernel is extensible by allowing third party kernel modules to be loaded into it at runtime. Loading a kernel module is the only supported way to get third party code to run inside Ring 0 (kernel mode). On modern versions of Windows, kernel modules must be signed to allow them to load.", "", "When the kernel loads a kernel module, the module's executable (which is stored as a PE file on disk) will be mapped into the kernel's virtual address space. We have previously seen the same mechanism used for loading a DLL into a process - the DLL PE file was mapped into the process address space. The two approaches are exactly the same.", "", "The kernel maintains a list of *\\_LDR\\_DATA\\_TABLE\\_ENTRY* structs to keep track of loaded kernel modules. The list head is kept at symbol \"nt!PsLoadedModuleList\" and Rekall can therefore list all loaded kernel modules (Since this is a doubly linked list it is trivial to unlink once malware has kernel execution so take it with a grain of salt).", "", "The kernel modules are simply mapped PE files as explained before, and therefore can be dumped using the **moddump** plugin."], "type": "markdown", "id": 1426886882283}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "Print list of loaded kernel modules.", "description": "Print list of loaded kernel modules.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "short_opt": "", "name": "name_regex", "help": "Filter module names by this regex."}, {"default": null, "positional": false, "short_opt": "a", "name": "address_space", "help": "The address space to use."}], "name": "modules"}}, "type": "rekallplugin", "id": 1426887264211}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "Dump kernel drivers from kernel space.", "description": "Dump kernel drivers from kernel space.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": false, "short_opt": "D", "default": null, "required": false, "help": "Path suitable for dumping files. (Default: Use current directory)", "name": "dump_dir"}, {"dest": "SUPPRESS", "positional": false, "short_opt": "", "name": "out_fd", "help": "A file like object to write the output."}, {"default": ".+", "positional": false, "short_opt": "", "name": "regex", "help": "A Regular expression for selecting the dlls to dump."}], "name": "moddump"}}, "type": "rekallplugin", "id": 1427499357542}, {"source": ["# Conclusions", "", "This chapter focused on extracting files from memory. First we learned how files are mapped into memory and in particular how PE files are mapped. We learned that not all file pages are resident in memory, and therefore we are not likely to have complete files when we extract them from memory. ", "", "We then saw that the registry files are mapped into memory and we learned how these can be read. Again we find that not all parts of the registry file are mapped into memory. Although we can dump these out, there are likely to be holes padded with zeros for those HBINs which are not mapped."], "type": "markdown", "id": 1426895005156}], "sessions": [{"state": {"profile": ["nt/GUID/2BCBB42C1BC741DF9E1D4E2D28DAC9631", "FileName"], "timezone": ["UTC", "TimeZone"], "ept": [null, "IntParser"], "pagefile": [[], "FileName"], "session_name": ["Windows Server 2012", "String"], "filename": ["../images/Windows_Server-2012-R2_RTM-English-64Bit-Base-2015.02.11.aff4", "FileName"]}, "mro": "InteractiveSession:JsonSerializableSession:Session:object", "id": 160, "session_id": 1}], "filename": "/home/scudette/projects/workshop/source/05-Windows_Memory_Analysis"}