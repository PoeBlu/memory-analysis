{"cells": [{"source": ["# Lets talk about memory...", "", "What is physical memory? In order to understand memory analysis we must first understand how memory is accessed and manipulated in a real machine. First lets look at what memory looks like, [first under a microscope](http://upload.wikimedia.org/wikipedia/commons/9/9b/MT4C1024-HD.jpg) then [schematically](http://cpuville.com/Z80.htm):", "", "", ""], "type": "markdown", "id": 1426424727236}, {"source": {"files": [{"type": "image/jpeg", "name": "MT4C1024-HD.jpg"}, {"type": "image/jpeg", "name": "schematic_1.jpg"}], "caption": "A microscope image of DDR3 memory. You can just make out the rectangular tracks for the address and data buses within the chip.\n\nBelow - A high level schematic for an Old Z80 based computer. The Z80 accesses the address and data buses directly without an MMU.", "size": 0}, "type": "fileupload", "id": 1426425048386}, {"source": ["", "", "The diagram is of an old Z80 computer (made in 1980)! Back in those days memory was used directly by the CPU. As the diagram shows, when the CPU wants to read a byte from memory, the CPU dials up the correct address on the *address bus* and then simply reads the data from the *data bus*. Those were the good old simple days.", "", "Today we have more abstractions behind memory but the concept is similar - there is an address bus connecting to the RAM chip itself, and when  an address is dialed up on the bus, the data bus will contain the data. These days however, the CPU is not directly connected to the RAM chip, but goes through a Memory Management Unit (MMU).", "", "Another interesting thing to note is that Read Only Memory (ROM) and peripherals are sharing the address bus and data buses with the RAM chip. What this means is that when the address bus contains addresses in certain ranges, different devices put data on the data bus. For example say that the RAM chip will only answer to addresses between the ranges 0x1000-0x2000, then only when the address bus contains addresses in that range, will the RAM chip attempt to control (i.e. inject electric current on) the data bus. For other addresses the RAM chip will ignore the address bus completely, as if it is not present at all.", "", "This scheme allows multiple different devices to be connected to the same address and data buses as long as they are mapped (i.e. respond to) different address ranges.", ""], "type": "markdown", "id": 1426425477527}, {"source": ["### What happens when the system boots?", "", "When the system boots the bios needs to map all devices into the address bus. Obviously if different devices are mapped to the same address ranges, this can damage the system because they will both be trying to control (i.e. inject electric current) on the data bus in the same time (it can actually burn out the memory chip drivers if this happens!).", "", "So the bios needs to program the different devices to ensure they do not overlap. In modern systems, the BIOS does not actually map memory mapped IO devices (this is left to the operating system), but the BIOS needs to program the RAM chips into their respective ranges, while at the same time reserving regions for the OS's PnP facilities to actually map devices DMA into.", "", "Therefore the BIOS will build an initial **Physical Memory Layout map**. The BIOS (The Northbridge) then conveys this information to the operating system during system boot - specifically which regions are *available* for the OS to use and which are *reserved* for DMA mappings.", "", "The figure below shows a typical BIOS memory map on the left, and a typical final mapping as configured by the operating system's plug and play facilities:"], "type": "markdown", "id": 1426425747102}, {"source": {"files": [{"type": "image/jpeg", "name": "physical_memory_layout.jpg"}], "caption": "A typical Physical memory layout as reported by the BIOS. The regions marked reserved are further subdivided into DMA buffers to PCI deviced by the operating system.", "size": 1}, "type": "fileupload", "id": 1426426578375}, {"source": ["It should be noted that the BIOS may not actually map physical RAM memory to the reserved regions. They are just gaps in the address space where PCI devices should map their DMA buffers. Since RAM is a scarce resource, the BIOS should generally not waste it on reserved areas. On the other hand some PCI devices only have a 32bit address bus, and therefore there must be a large enough region reserved below the 4Gb limit to allow these to be mapped.", "", "It follows then, that the largest accessible physical memory address is going to be much larger than the contents of RAM in the system (since reserved gaps will expand it). ", "", "This is often a confusing point for people who acquire images in the RAW format - why is the size of the image much larger than the amount of RAM installed? This is because the RAW format must pad reserved regions with zeros (to maintain alignment).", "", "### What happens when we read inside the reserved areas?", "", "We know that the regions marked *available* are available for the OS to use and are backed by suitable RAM chips. But what happens when we read outside this? Often nothing at all! If there is no RAM chip mapped at this region, there is nothing there at all - When you read from it you get zeros.", "", "However sometimes there is a PCI DMA region mapped into the reserved region. What happens when we read from that? Looking back at the first diagram we can see that when the address bus contains the value of the address in the reserved region, the PCI device configured to respond to that address may activate. At this point anything is really possible since the hardware expects that the data bus will contain valid data to act on. Usually the hardware will detect an error and the machine will either bluescreen or crash hard.", "", "It is therefore dangerous for imaging tools to try to read from the reserved regions - in case there are DMA devices mapped there. Most imaging tools avoid these regions by first asking the kernel about them (e.g. in windows an API called MmGetPhysicalAddressRanges).", "", "It is quite trivial for malware to manipulate the data structures that the kernel maintains about the physical layout. This can easily fool memory analysis tools.", "", "Another interesting property we can see in the image above is that it is possible to have some hidden memory inside the reserved regions. Sometimes due to RAM address alignment limitations, the BIOS will overlap some of the reserved region with RAM chips. In that case writing to that region will actually maintain data (i.e. a read operation will recover the original data). In this case it is possible to store some non-trivial data in regions where memory imagers do not dare to read."], "type": "markdown", "id": 1426426996719}, {"source": ["# Memory acquisition", "", "How do we acquire memory? Acquision methods are broadly divided into hardware and software methods.", "", "## Hardware based memory acquisition.", "", "Although in the past it was possible to acquire memory via Firewire, or a special PCI device, in reality these methods are no longer practical. Acquisition through Firewire is brittle, but even when it works it is only possible to acquire the lower 4Gb of RAM, which on modern systems is just not enough.", "", "By far the most practical way for acquiring memory in hardware is through Virtual Machines. When a guest VM is running inside a virtualization solution, it is often possible to pause the VM and perfectly preserve the state of (virtual) RAM. This is quite a unique ability and actually produces a perfect memory image.", "", "## Software based memory acquisition.", "", "If the target we need to acquire is not running inside a virtualization solution, we must use a software aquision technique. This is a program running within the target which copies out physical memory into an image file.", "", "### Image file format.", "", "Before we consider the different memory imaging tools, let us first examine how the image is stored - the image file format.", "", "By far the simplest image file format is the RAW format. In this format, the physical address space is written byte for byte directly into the image file. ", "", "* Pros:", "  * RAW files are very very simple, no special requirements are needed to read the file.", "", "* Cons:", "  * No ability to store sparse regions - all reserved regions must be padded in the image with zeros giving a larger image size.", "  * No support for compression, encryption etc.", "  * No support for additional metadata.", "  * No support for embedding additional files, such as the pagefile, kernel image etc.", "", "For this reason there are a number of different file formats employed:", "", "1. The Microsoft Crashdump file, for example, is commonly used with windows images - however this is a proprietary, undocumented file format with no support for compression or embedding (although it supports some windows specific metadata) it is also non-extensible. We do not recommend acquiring with this format directly - if you need to analyze the image with the windows debugger we recommend using the Rekall **raw2dmp** plugin to create a dump file later.", "2. An ELF core file is the standard image format used by GDB and Linux when making a core dump. This format allows the storage of sparse memory regions, but has only limited support for extensible metadata. It is not possible to use this format to collect related files (like the pagefile, kernel image etc). This format is the default produced by versions of Rekall's *pmem* acquisition tools prior to version 2.0. Certain virtualization tools like Virtual Box produce memory images in this format so it can still be useful.", "3. EWF is a compression format which is used by Encase. It offers the ability for the image to be compressed but does not support sparse files, nor multiple streams (at least the versions supported by the open source libewf tool).", "4. Various ad-hoc imaging formats that are sometimes used. Rekall can read those if you receive them in this format:", " * Limes - an ad-hoc imaging format sometimes used on Linux.", " * HPAK - A propritary format used in HBGary's tools.", " * Mach-O - This is the binary format used on OSX. These kind of images used to be produced by the now defunct \"Mac Memory Reader\".", "", "After version 2.0 Rekall's pmem suite of acquisition tools have switched to the AFF4 format for the default image format. AFF4 is:", "", "* A peer reviewed open standard for storing digital images.", "* Supports compression using the Zlib and Snappy protocols - allows imaging at speeds greated than 300mb/s.", "* Supports storing arbitrary metadata via RDF information triples.", "* The image file format is a simple Zip file, with all the advantages that brings:", "  * Readily available tools for recovery of corrupted image files.", "  * Readily available tools for inspection, verification and manipulation of the image format.", "  * Built in support in almost every programming language - decompressing an AFF4 stream can be done in 4 lines of python without the use of the AFF4 library.", ""], "type": "markdown", "id": 1426428049991}, {"source": ["##  AFF4 overview.", "", "Why did Rekall decide to switch to AFF4 as the standard imaging format? One of the reasons we started writing imaging tools inside the Rekall project was to provide a full end-to-end imaging + analysis solution for memory forensics needs. As we developed more features into our imaging tools we found that we can exploit the synergy between the acquisition and analysis parts of the project, in order to make analysis more powerful. Put simply, we can make our analysis simpler and more robust if we can collect more information at acquisition time.", "", "For example there is a lot of code in Rekall to try to guess the version of the kernel which is running in the image. But the imager already knows this because it can just call an API to ask about it! Because the Rekall project owns both the analysis and the acquisition components, Rekall is in a unique position to simply get the imager to collect additional information, saving the analysis part from figuring out this detail.", "", "We therefore wanted an imaging format which we can use to store arbitrary metadata, and that we can extend very easily.", "", "Similarly, as we developed Rekall's analysis capabilities we realized that the pagefile is extremely important in the analysis of userspace programs. We then wanted to also collect the pagefile by default. AFF4 allows us to store multiple streams in the same image. So we can store all the pagefiles, the physical memory stream, the kernel image and all the drivers on the system in the same AFF4 file (in AFF4 terminology it is called an AFF4 volume).", "", "In future we will probably continue to extend the metadata that the imager collects to provide the Rekall analysis engine with more information, thereby making it more powerful. We therefore recommend that images be taken with *pmem*'s default AFF4 format as much as possible."], "type": "markdown", "id": 1426431239944}, {"source": ["Lets examine what an AFF4 volume contains. The following is an image of a Windows Server 2003 system, acquired together with the pagefile:"], "type": "markdown", "id": 1426433900483}, {"source": "unzip -l images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4", "type": "shell", "id": 1426432076242}, {"source": ["We can see that the AFF4 volume is denoted by a globally unique name **aff4://4928ef44-6579-496c-a53e-2ad34d98b7ed**. This is called the AFF4 URN and uniquely identifies this volume. The metadata is stored in this volume's archive member called \"information.turtle\". We also see a number of streams - The PhysicalMemory is the memory stream of the machine's physical memory, \"c%3a/pagefile.sys\" is the stream corresponding with the machine's pagefile.", "", "Lets examine the metadata:"], "type": "markdown", "id": 1426433971953}, {"source": "unzip -p images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4 information.turtle", "type": "shell", "id": 1426434167257}, {"source": ["There are 3 streams - The **PhysicalMemory** stream is sparse and hence is of type *aff4:map*. The data is actually backed by **PhysicalMemory/data**. Rekall can automatically use this image and all its componets - the pagefiles are automatically used without user intervention. "], "type": "markdown", "id": 1426434241789}, {"source": ["# The PMEM suite of acquisition tools.", "", "The Rekall project maintains a set of acquisition tools for the three supported operating systems: Windows, Linux and OSX. Since version 2.0, the three imagers have been merged into a single common framework. This means that you use them in the same way, and they all produce the same type of AFF4 images.", "", "All imagers share the common AFF4 imager. This means you can use all imagers for basic manipulation of all AFF4 volumes. Hence we will discuss these common features here. Below we discuss some of the differences in the implementations between the operating systems.", "", "", "Lets consider the output from the --help command:", "", ""], "type": "markdown", "id": 1426435107122}, {"source": "linpmem --help", "type": "shell", "id": 1426434638790}, {"source": ["## Inspecting an AFF4 Volume.", "", "The tool can examine an AFF4 volume as we have seen previously. It actually loads the provided AFF4 volume and outputs a common view of all known objects."], "type": "markdown", "id": 1426435577191}, {"source": "linpmem -V images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4", "type": "shell", "id": 1426435637950}, {"source": ["## Extracting a stream from an AFF4 volume.", "", "We can extract one of the streams to a file. For example, we can extract the pagefile into the /tmp/ directory:"], "type": "markdown", "id": 1426435719407}, {"source": "linpmem --export /c:/pagefile.sys --output /tmp/pagefile.sys images/Windows_Server-2003-R2_SP2-English-32Bit-Base-2015.02.11.aff4", "type": "shell", "id": 1426441759666}, {"source": ["# Adding a new stream to an AFF4 volume.", "", "By default the AFF4 imager tools append streams to existing volumes, rather than overwrite the volume. Therefore it is easy to add additional files after the acquisition is complete to the acquired volume. It is also possible to specify shell globs to add multiple files to the volume. In this sense, the AFF4 volume acts more like a zip container - you can just keep on adding new files.", "", "This is handy if initial analysis reveals some suspected files which we can acquire immediately into the AFF4 volume after the memory is captured. The **-t** flag allows pmem to truncate the output file (this will delete all current content of the volume)."], "type": "markdown", "id": 1426446371053}, {"source": "echo \"Acquiring files in /bin/\"\nlinpmem -i /bin/* -o /tmp/test.aff4 -t\n\necho \"Content of volume:\"\nlinpmem -V -v /tmp/test.aff4", "type": "shell", "id": 1426446574705}, {"source": ["## Inspecting live memory", "", "One of the most important differences between the *Pmem suite* and other memory acquisition tools is that most other acquisition tools dump the memory image from kernel space, arguably in order to minimize system disturbance and reduce overheads in copying large quantities of data across the kernel/userspace boundary.", "", "Unfortunately dumping memory from kernel space has some serious limitations:", "", "- It is difficult to support more complex image storage formats as all code must run in kernel space - so no access to libraries.", "- Much more complex code is running in kernel space - a bug in this code will bring down the entire machine (or blue screen it).", "", "When Pmem was designed we have made a design choice to have a simple kernel mode component which simply exposes an interface to userspace. In our experience the additional overheads in copying memory from kernel to userspace is insignificant in practice, but this gives us the following advantages:", "", "- The userspace component can implement a complex, complete imaging format.", "- Complex userspace code is contained inside a process - a bug will not bluescreen the machine - it will simply cause the imaging tool to crash. This is much safer and enabled us to implement more complete imaging solutions.", "", "But most importantly, having a driver export a device to physical memory enabled us to easily attach to the device with Rekall. Rekall can then inspect the real, live memory of the system without the need to take an image first.", "", "This approach opens up some exciting possibilities:", "", "1. We can automate memory analysis such that we can triage a system very quickly based on analysis of its live memory. This might mean that we do not need to acquire memory in many cases - perhaps we have a yara signature we can use to determine if the system is of interest. Running it on live memory is very quick and will enable us to triage the system, saving us from taking, transporting, storing and archiving yet another memory image.", "2. The possibility of quickly triaging a system based on live memory analysis can be extended to remote response tools such as GRR. GRR can run a \"memory hunt\" on an entire fleet of machines checking for memory artifacts directly from live memory.", "3. When machines have a large amount of memory, the issue of memory smear becomes significant - as the imaging tool is acquiring the memory, the memory itself is changing. Therefore information in some parts of the image will be out of sync to data in other parts. Smear becomes significant for servers (which typically have a huge amount of memory - more than 128GB - this might take up to 10 minutes to image, an eternity in computer scale). By analysing live memory we can selectively read only the important  regions and therefore minimize the time window for the memory to change.", "", "We believe that live memory analysis is the future of memory forensics, and will enable us to scale to analysis of very large systems (which are becoming more common all the time). We are therefore excited to have a suite of memory imaging tools which enable this mode of analysis.", "", "The next example shows how one would analyse live memory on windows."], "type": "markdown", "id": 1426761568250}, {"source": {"files": [{"type": "image/jpeg", "name": "livemode.jpg"}], "caption": "Live Memory Analysis on windows using WinPmem", "size": 1}, "type": "fileupload", "id": 1426762823201}, {"source": ["1. First a command prompt is opened with administrative privilege (Right click on the cmd.exe icon and select \"Run As Administratory\"", "2. Next we load the driver using the -l switch to winpmem. This tells winpmem we want to have the driver loaded and left loaded instead of taking a memory image. Winpmem will quite as soon as the driver is loaded.", "3. Now we launch Rekall, giving the name of the winpmem device as the filename - *\\\\\\\\.\\\\pmem*.", "", "Rekall will continue analyzing live memory in exactly the same way as if it was an image, except we do not need to copy and ship a large image around."], "type": "markdown", "id": 1426762879441}, {"source": ["## The WinPmem acquisition tool.", "", "On Windows, one must insert a signed driver in order to gain access to physical memory. WinPmem from version 2.0 is built on top of the AFF4 imager technology, and is packaged bundled with the appropriate memory drivers. Since AFF4 volumes utilize zip file, as their underlying storage format, it is possible to append an AFF4 volume to the end of any other file type. The WinPmem acquisition tool utilizes this property to simply package all needed drivers and tool in the executable itself - using the AFF4 format.", "", "We typically package with winpmem the 64 bit and 32 bit windows kernel drivers, as well as a copy of fcat.exe from the [sleuthkit ](http://www.sleuthkit.org). This tool is used to provide access to the locked pagefiles.", "", "If no other operation was specified, WinPmem will immediately image memory, pagefiles and also acquire certain files, such as drivers and the kernel image. These are useful to preserve the exact versions of binaries running on the system at the time of the acquisition.", "", "By default WinPmem uses a technique called **PTE Remapping** to acquire memory. This technique is illustrated below and was originally developed in order to bypass potential malware hooking the APIs normally used for acquisition. After much use we found that the technique is in fact more stable than using the APIs and it is actually the only reliable way that access to physical memory is achievable on OSX. We therefore decided to make this the default acquisition mode."], "type": "markdown", "id": 1426448748611}, {"source": {"files": [{"type": "image/jpeg", "name": "pte_acquisition.jpg"}], "caption": "Figure 4: Illustration of the PTE remapping technique.", "size": 0}, "type": "fileupload", "id": 1426449461463}, {"source": ["The PTE remapping technique works in the following steps:", "", "1. A page is requested from the operating system to the driver's use. The page is locked into memory (so it can not be paged out).", "2. The PTE of this page is found and directly modified in order to point at another desired page in physical memory.", "3. The Translation Lookaside Buffer (TLB) is flushed (this is essentially a cache of page translated addresses). This forces the hardware to notice the modified PTE.", "4. We now simply read from the page - the data is coming from the physical page we selected earlier.", "", "The strength of this technique is that the OS is not aware that any mapping has occurred - the PTE is allocated to our use and will not be used by the system itself. The translation is done by the hardware and the operating system is not aware it is being imaged."], "type": "markdown", "id": 1426449484496}, {"source": ["# Virtual Memory", "", "In the start of this chapter we mentioned that although ancient CPUs directly controlled the address bus, these days the CPU is not directly connected to the address bus but must go through an MMU instead. In **Protected mode** the CPU's address lines are translated by the MMU before being forwarded to the main system bus seen by the RAM chips."], "type": "markdown", "id": 1426451006412}, {"source": {"files": [{"type": "image/jpeg", "name": "virtual_address_space.jpg"}], "caption": "The \"Virtual Address Space\" is the visible by the CPU. CPU memory access are made through the Memory Manager unit and are being transformed into the physical address space.", "size": 0}, "type": "fileupload", "id": 1426451362106}, {"source": ["The translation is made automatically by the hardware, using pre-populated page tables found in memory. The page tables are pre-configured and managed by the operating system. The exact process of translating the address is outlined in Figure 4, but conceptually the translation can simply be though of as a pre-configured substitution between virtual addresses to physical addresses. The key for this substitution is the value of (Control Register 3) CR3 which is a pointer to a dedicated address in memory where the operating system has pre-configured the page tables.", "", "But why do such a thing? Why are modern CPUs not directly connected to memory like the Z80 example we showed earlier? The below figure shows how useful address translation can be."], "type": "markdown", "id": 1426451521420}, {"source": {"files": [{"type": "image/jpeg", "name": "virtual_memory2.jpg"}], "caption": "Virtual Addresses allows physical memory to be shared by many processes in many different ways.", "size": 0}, "type": "fileupload", "id": 1426452319798}, {"source": ["The figure shows physical memory is divided into frames, each of size 0x1000 bytes. However, due to the virtual address translation, each running processes is running in its own Virtual Memory Address Space. That is to say that when the process is scheduled by the operating system, the OS loads a different value into CR3 register, thereby affecting a different transformation between virtual addresses and physical memory. ", "", "In this way each process can see its own virtual address space, which is distinct from other process's virtual address spaces. Now the operationg system can finely control the view of the process's virtual address space and exactly which memory the process has access to:", "", "1. The operating system can implement shared memory by simply mapping different pages in different virtual address spaced, into the same physical page. This effectively allows different processes to share physical memory and can be used to facilitate communication between them.", "2. The operating system can map a virtual page into an actual physical memory frame - this is termed \"backed memory\" - i.e. there is actual memory backing the virtual address.", "3. If the page not been used for a while the OS can simply mark the page table entry (PTE) belonging to a virtual address in a special way and move the page into the pagefile. Now if the process attempts to access the page, the hardware will generate a page fault and the OS can bring the page back from the pagefile to be used by the application. Thus virtual addressing enabled the OS to implement a page file at all.", "4. The OS can overcommit memory for the process. It is possible for process to request a lot of memory, \"just in case\" and not actually use it. The OS does not have to actually commit the memory when the process requests it - rather, the OS can overcommit and then, if the process attempts to use the page later, can worry about mapping something in to back the requests. This strategy enables the OS to flexibly respond to varying memory pressure from processes and therefore achieve much higher responsiveness.", "5. File mapping - Similarly a process can map a file into its address space. From the process's point of view the entire file is present inside its virtual address space. When the process attempts to access a part of the file, the OS may read only the relevant part and lock that into memory. This kind of access is commonly used to map executables into many processes (but sharing the file mapped data)."], "type": "markdown", "id": 1426452407232}, {"source": ["# Virtual Machines", "", "In the previous section we discussed how the page tables maintained by the operating system gave each process their own unique view of their Virtual Address Space. The OS can maintain process separation and finely control how much of the memory the processes share. Virtual machines are an extreme example of process separation - in fact the goal is to completely separate different operating systems themselves, while allowing them to share the physical memory of the host machine.", "", "In order to separate the address spaces of multiple guest machines, modern hardware supports a standard called VTx. The gory details are discussed in the blog post [VM discovery and introspection with Rekall](http://www.rekall-forensic.com/posts/2014-10-03-vms.html), but conceptually VTx introduces an additional type of translation table called EPT, which just like regular page tables perform translation between the Guest's virtualized physical memory and the host's physical memory. The hypervisor sets up these tables in advance and the hardware does the rest."], "type": "markdown", "id": 1426453585949}, {"source": {"files": [{"type": "image/jpeg", "name": "EPT_translation.jpg"}], "caption": "Illustration of the EPT translation between the Guest's virtualized Physical Memory and the Host's Physical Memory.", "size": 0}, "type": "fileupload", "id": 1426453986452}, {"source": ["When a process inside the VM access an address in it's virtual address space:", "", "1. The CPU uses the CR3 value loaded to calculate the Virtualized Physical Address for the guest VM.", "2. The hypervisor then uses the EPT to translate between the guest's physical address space and the hosts' physical memory.", "3. Data is fetched from the host's physical memory."], "type": "markdown", "id": 1426454090782}, {"source": ["# Examining memory on a Virtual Machine.", "", "To visualize how memory works we took an image of an Ubuntu 14.10 system running the Virtual Box virtualization solution. The system has two virtual machines: A Windows 7 machine, and another Ubuntu machine this time running an x86 (32 bit) Ubuntu 14.10 distribution. ", "", "Since the system we will analyse is a Linux system we must provide it with a profile (See chapter 3 - \"Profiles and Multi OS Support.\" for details of how to build a profile). We have built a profile previously for this system and it is called 3.16.0-23-generic_amd64.json. You will find all files in the images directory of this document.", "", "We first click the *Session* button at the toolbar above. Then select the image file, and profile file. Clicking anywhere outside the modal dialog with save our changes.", "", "Lets see if we can list files on this image.", "", "Click the \"Add Cell\" button on the toolbar and select to add a \"Rekall Plugin\" (alternative just press c followed by r, c-r)."], "type": "markdown", "id": 1426641308677}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "List the sessions available.", "description": "List the sessions available.", "requirements": [], "arguments": [{"positional": true, "short_opt": "", "name": "session_id", "help": "The session id to change to"}], "name": "slist"}}, "type": "rekallplugin", "id": 1426939785726}, {"source": ["The above is the process listing of processes on the host machine.", "", "We can look for virtual machines using the **vmscan** plugin. This plugin will also create suitable sessions for each image. In Rekall a session is an object encapsulating everything Rekall knows about a particular image. When we have several virtual machines within the same image, we actually need multiple sessions, since each virtual machine is unrelated to the others (even though it came from the same image)."], "type": "markdown", "id": 1426642393275}, {"source": {"arguments": {}, "session_id": 1, "plugin": {"short_description": "Scan the physical memory attempting to find hypervisors.", "description": "Scan the physical memory attempting to find hypervisors.\n\n    Once EPT values are found, you can use them to inspect virtual machines\n    with any of the rekall modules by using the --ept parameter and\n    specifying the guest virtual machine profile.\n\n    Supports the detection of the following virtualization techonlogies:\n      * Intel VT-X with EPT. Microarchitectures:\n        + Westmere\n        + Nehalem\n        + Sandybridge\n        + Ivy Bridge\n        + Haswell\n\n      * Intel VT-X without EPT (unsupported page translation in rekall).\n        + Penryn\n\n    For the specific processor models that support EPT, please check:\n    http://ark.intel.com/products/virtualizationtechnology.\n    ", "requirements": ["physical_address_space"], "arguments": [{"positional": false, "short_opt": "V", "default": 1, "help": "An integer reflecting the amount of desired output: 0 = quiet, 10 = noisy. Default: 1", "type": "IntParser", "name": "verbosity"}, {"positional": false, "short_opt": "", "default": false, "help": "Perform quick VM detection.", "type": "Boolean", "name": "quick"}, {"positional": false, "short_opt": "", "default": false, "help": "Don't do nested VM detection.", "type": "Boolean", "name": "no_nested"}, {"positional": false, "short_opt": "", "default": 0, "help": "Offset in the physical image to start the scan.", "type": "IntParser", "name": "offset"}, {"positional": false, "short_opt": "", "default": false, "help": "Also show VMs that failed validation.", "type": "Boolean", "name": "show_all"}, {"positional": false, "short_opt": "", "default": false, "help": "The image is for a guest VM, not the host.", "type": "Boolean", "name": "image_is_guest"}, {"positional": false, "short_opt": "", "default": false, "help": "[DEBUG SETTING] Disable validation of VMs.", "type": "Boolean", "name": "no_validation"}], "name": "vmscan"}}, "type": "rekallplugin", "id": 1426642538785}, {"source": ["The vmscan plugin discovers Virtual Machine Control Structures (VMCS) in physical memory. Remember that the VMCS and EPT tables are set up for the hardware by the virtualization solution. Therefore the precise structure of these tables is determined by the hardware not the virtualization solution. For this reason, we don't necessarily need to support any specific Virtualization Technology (e.g. Vmware, VirtualBox or KVM) - Rekall merely needs to support the particular CPU used.", "", "The table above shows two virtual machines. The first is a 32 bit operating system (as is indicated by the *I386+PAE*). Note the reported locations of the EPT page tables. These are the only tables we need in order to translate the addresses.", "", "The vmscan plugin also creates new sessions for the VMs. Click on the \"Session\" button above and find the session corresponding to the first EPT location. We know this is an Ubuntu system, so we must provide the profile (named 3.16.0-23-generic_x86.json). Note that initially the vmscan plugin names the sessions by the offset of the EPT since it has no idea what OS is actually running in the guest. For our ease of use we can rename the sessions Ubuntu Guest and Win7.", "", "Lets list processes in each of the VMs. You can select the session that will apply to each plugin using the pull down selector in the Rekall cell."], "type": "markdown", "id": 1426642645442}, {"source": {"arguments": {}, "session_id": 3, "plugin": {"short_description": "Print process list as a tree", "description": "Print process list as a tree", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": false, "short_opt": "V", "default": 1, "help": "An integer reflecting the amount of desired output: 0 = quiet, 10 = noisy. Default: 1", "type": "IntParser", "name": "verbosity"}], "name": "pstree"}}, "type": "rekallplugin", "id": 1426643041802}, {"source": ["Lets inspect the Windows 7 machine more closely. We run the *imageinfo* plugin to learn a bit about it."], "type": "markdown", "id": 1426644467482}, {"source": {"arguments": {}, "session_id": 3, "plugin": {"short_description": "List overview information about this image.", "description": "List overview information about this image.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}], "name": "imageinfo"}}, "type": "rekallplugin", "id": 1427482055106}, {"source": ["Note that the plugin also displays the physical memory layout of the Win7 guest VM.  We can see there are two ranges valid for this physical memory.", "", "### Examining the Virtual Address Space of the kernel.", "", "As described above, in protected mode, the CPU can not access the physical memory directly. The MMU is responsible for translating between virtual addresses to physical addresses. Rekall replicate this behavior by stacking address spaces on top of one another, each address space is responsible for one level of translation.", "", "When a read request occurs, Rekall relays the request to the *AddressSpace()* object which translate this address into a read from its base address space (i.e. the address space below it in the stack). ", "", "Lets examine this concept using the *inspect_vaddr* plugin. We select to inspect the Windows 7 Virtual Machine by selecting the correct session:"], "type": "markdown", "id": 1426644505194}, {"source": {"arguments": {"address": "nt"}, "session_id": 3, "plugin": {"short_description": "Inspect the mapping of a virtual address.", "description": "Inspect the mapping of a virtual address.", "requirements": [], "arguments": [{"positional": true, "short_opt": "", "help": "Virtual address to inspect.", "required": true, "type": "SymbolAddress", "name": "address"}], "name": "inspect_vaddr"}}, "type": "rekallplugin", "id": 1427497386995}, {"source": ["Note that the plugin accepts a single *address* parameter. This parameter can be an actual address or the name of a symbol. Rekall knows how to identify symbols by name so specifying addresses by name is very convenient. In this example, we specify \"nt\" as the symbol name (this is the base address of the kernel image itself). You can try other symbols, like \"nt!MmGetPhysicalMemoryRanges\" which is a windows kernel function.", "", "In the above we see that the symbol was resolved into the address **0xf80002659000**. Reading from the kernel's address space will translate this into a read of the VTxPagedMemory address space (using the EPT at 0x881af01e) for an offset of **0x265900**. Note that this translation is governed by the windows kernel page tables inside the virtual machine itself.", "", "The VTxPagedMemory address space simply uses the EPT tables to resolve an address in the guest's physical address space to a address in the host's physical address space. Note that since this is hardware virtualization, the host's operating system has nothing to do with this translation - it is all done in the VTx hardware. The host's OS is only responsible for managing the EPT page tables.", "", "The next step shown is that the Guest's physical address 0x2659000 is translated to the offset 0x12082a000 in the image itself. The image is stored in the AFF4 format, hence we have the AFF4AddressSpace to read from it.", "", "We mentioned that the first part of the translation is from Guest Virtual Address to Guest Physical Address and it is governed by normal 64 bit page tables. We can see how this looks by using the *vtop* plugin to show us how a virtual address is translated to a physical address in the guest's session:"], "type": "markdown", "id": 1426684461372}, {"source": {"arguments": {"virtual_address": "nt"}, "session_id": 3, "plugin": {"short_description": "Prints information about the virtual to physical translation.", "description": "Prints information about the virtual to physical translation.", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "eprocess", "help": "Kernel addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_eprocess", "help": "Physical addresses of eprocess structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"positional": false, "short_opt": "", "default": null, "help": "A regex to select a process by name.", "type": "RegEx", "name": "proc_regex"}, {"positional": false, "short_opt": "", "default": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "help": "Method to list processes (Default uses all methods).", "choices": ["PsActiveProcessHead", "CSRSS", "PspCidTable", "Sessions", "Handles"], "type": "ChoiceArray", "name": "method"}, {"positional": true, "short_opt": "", "help": "The Virtual Address to examine.", "required": true, "type": "SymbolAddress", "name": "virtual_address"}], "name": "vtop"}}, "type": "rekallplugin", "id": 1427497380275}, {"source": ["We can see the plugin explain how the virtual address is translated through the 4 level page table located in 0x187000. The important information from here is that the page is valid and therefore mapped into the physical address space.", "", "If the page was not valid, the CPU would generate a page fault for the OS when the page is accessed. This page fault interrupt tells the OS that the hardware is unable to simply resolve the page and needs assistance from the OS."], "type": "markdown", "id": 1426685406927}, {"source": ["## The Ubuntu guest VM.", "", "Lets examine our Ubuntu guest VM."], "type": "markdown", "id": 1426644665312}, {"source": {"arguments": {}, "session_id": 2, "plugin": {"short_description": "Gathers active tasks by walking the task_struct->task list.", "description": "Gathers active tasks by walking the task_struct->task list.\n\n    It does not display the swapper process. If the DTB column is blank, the\n    item is likely a kernel thread.\n    ", "requirements": ["profile", "physical_address_space"], "arguments": [{"positional": false, "critical": true, "short_opt": "p", "name": "profile", "help": "Name of the profile to load. This is the filename of the profile found in the profiles directory. Profiles are searched in the profile path order."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "dtb", "help": "The DTB physical address."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "pid", "help": "One or more pids of processes to select."}, {"default": null, "positional": false, "short_opt": "", "name": "proc_regex", "help": "A regex to select a process by name."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "phys_task", "help": "Physical addresses of task structs."}, {"positional": false, "type": "ArrayIntParser", "short_opt": "", "name": "task", "help": "Kernel addresses of task structs."}, {"positional": false, "type": "IntParser", "short_opt": "", "name": "task_head", "help": "Use this as the first task to follow the list."}, {"positional": false, "short_opt": "", "help": "Method to list processes (Default uses all methods).", "choices": ["InitTask"], "nargs": "+", "name": "method"}], "name": "pslist"}}, "type": "rekallplugin", "id": 1427482128871}, {"source": ["# Summary", "", "In this module we saw how memory is used by a computer system. We learned that the CPU running in protected mode can not access physical memory directly. The MMU is responsible for translating the Virtual Address the CPU is referencing into a physical address. ", "", "Rekall emulates the MMU's function by using the address space object. Rekall layeres address spaces on top of each other to emulate the way the hardware does it. We saw how multiple levels of indirections allows for virtual machines to share the same physical address space. We also saw how the EPT tables allow the hardware to emulate the guest's physical address space - allowing multiple different operating systems to run on the same host."], "type": "markdown", "id": 1426721305335}], "sessions": [{"state": {"profile": ["../images/3.16.0-23-generic_amd64.json", "FileName"], "timezone": ["UTC", "TimeZone"], "ept": [null, "IntParser"], "pagefile": [[], "FileName"], "session_name": ["Virtual Machine Host", "String"], "filename": ["../images/Ubuntu14.10_virtualbox.aff4", "FileName"]}, "mro": "InteractiveSession:JsonSerializableSession:Session:object", "id": 160, "session_id": 1}, {"state": {"profile": ["../images/3.16.0-23-generic_x86.json", "FileName"], "timezone": ["UTC", "TimeZone"], "ept": [[2148171806], "IntParser"], "pagefile": [[], "FileName"], "session_name": ["Ubuntu Guest", "String"], "filename": ["../images/Ubuntu14.10_virtualbox.aff4", "FileName"]}, "mro": "InteractiveSession:JsonSerializableSession:Session:object", "id": 186, "session_id": 2}, {"state": {"profile": ["nt/GUID/3844DBB920174967BE7AA4A2C20430FA2", "FileName"], "timezone": ["UTC", "TimeZone"], "ept": [[2283466782], "IntParser"], "pagefile": [[], "FileName"], "session_name": ["Win7 Guest", "String"], "filename": ["../images/Ubuntu14.10_virtualbox.aff4", "FileName"]}, "mro": "InteractiveSession:JsonSerializableSession:Session:object", "id": 213, "session_id": 3}, {"state": {"profile": ["nt/GUID/2BCBB42C1BC741DF9E1D4E2D28DAC9631", "FileName"], "timezone": ["UTC", "TimeZone"], "ept": [null, "IntParser"], "pagefile": [[], "FileName"], "session_name": ["Windows Server 2012", "String"], "filename": ["../images/Windows_Server-2012-R2_RTM-English-64Bit-Base-2015.02.11.aff4", "FileName"]}, "mro": "InteractiveSession:JsonSerializableSession:Session:object", "id": 241, "session_id": 4}], "filename": "/home/scudette/projects/workshop/source/02-What_is_memory"}